<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Insect">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Insect">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Insect">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> Insect </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Insect</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Hello world</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Kategorien
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/28/JSPatch实现解析/" itemprop="url">
                  JSPatch实现解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2017-02-28T17:04:12+08:00" content="2017-02-28">
              2017-02-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JSPatch轻量级的线上热更方案，通过加载js代码实现热更。</p>
<h2 id="JSPatch使用"><a href="#JSPatch使用" class="headerlink" title="JSPatch使用"></a>JSPatch使用</h2><h3 id="集成JSPatch"><a href="#集成JSPatch" class="headerlink" title="集成JSPatch"></a>集成JSPatch</h3><ol>
<li>添加JSPatch，只有三个文件 <a href="https://github.com/bang590/JSPatch/tree/master/JSPatch" target="_blank" rel="external">https://github.com/bang590/JSPatch/tree/master/JSPatch</a></li>
<li>添加JS热更代码，JS代码编写规则详细参考 <a href="https://github.com/bang590/JSPatch/wiki" target="_blank" rel="external">https://github.com/bang590/JSPatch/wiki</a></li>
<li><p>代码加载：</p>
<pre><code>-(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:        (NSDictionary *)launchOptions 
{
    [JPEngine startEngine];
    NSString *sourcePath = [[NSBundle mainBundle] pathForResource:@&quot;demo&quot; ofType:@&quot;js&quot;];
    NSString *script = [NSString stringWithContentsOfFile:sourcePath encoding:NSUTF8StringEncoding error:nil];
    [JPEngine evaluateScript:script];
}
</code></pre></li>
</ol>
<h2 id="JSPatch实现解析"><a href="#JSPatch实现解析" class="headerlink" title="JSPatch实现解析"></a>JSPatch实现解析</h2><h3 id="JS调用OC函数"><a href="#JS调用OC函数" class="headerlink" title="JS调用OC函数"></a>JS调用OC函数</h3><pre><code>  require(&apos;UIView&apos;)
var view = UIView.alloc().init()
view.setBackgroundColor(require(&apos;UIColor&apos;).grayColor())
view.setAlpha(0.5)
</code></pre><ol>
<li>使用require(‘UIView’)函数加类名，创建对应实例。</li>
<li><p>方法调用书写时直接使用方法名加参数，该段JS执行前会使用正则将方法调用改成 __c() 函数。</p>
<pre><code>UIView.alloc().init() -&gt; UIView.__c(&apos;alloc&apos;)().__c(&apos;init&apos;)()
</code></pre></li>
<li><p>__c()函数会将类名、对象指针、方法名、参数传递给OC。</p>
<pre><code>__c = function(methodName) {
    return _methodFunc(self.__obj, self.__clsName, methodName, args,             self.__isSuper)
}

_methodFunc = function(instance, clsName, methodName, args, isSuper, isPerformSelector) {
    var ret = instance ? _OC_callI(instance, selectorName, args, isSuper):
                 _OC_callC(clsName, selectorName, args)
  }
</code></pre></li>
<li><p>_OC_callI使用JSContext在OC里实现：</p>
<pre><code>  JSContext *context = [[JSContext alloc] init];
  context[@&quot;_OC_callI&quot;] = ^id(JSValue *obj, NSString *selectorName, JSValue     *arguments, BOOL isSuper) {
return callSelector(nil, selectorName, arguments, obj, isSuper);
};
</code></pre></li>
<li><p>callSelector函数里获得了所有OC方法调用需要的参数，最终使用NSInvocation调用OC函数。</p>
</li>
</ol>
<h3 id="OC调用JS函数（以方法替换为例）"><a href="#OC调用JS函数（以方法替换为例）" class="headerlink" title="OC调用JS函数（以方法替换为例）"></a>OC调用JS函数（以方法替换为例）</h3><pre><code>defineClass(&quot;JPViewController&quot;, {
      viewDidLoad: function() {
        ...
      }
}
</code></pre><ol>
<li>defineClass同样使用JSContext实现于OC，该函数会将对应类的对应方法的IMP指向_objc_msgForward，让方法调用走消息转发，并更改forwardInvocation实现。</li>
<li><p>保存旧方法到ORIG_selectname,保存新方法到全局字典：</p>
<pre><code>static NSMutableDictionary *_JSOverideMethods;
</code></pre></li>
<li><p>最终在forwardInvocation里从全局字典里获取对应方法的JSValue，使用[JSValue callWithArguments:]调用JS函数。</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/15/iOS图片解码绘制/" itemprop="url">
                  iOS图片解码绘制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2017-02-15T14:57:26+08:00" content="2017-02-15">
              2017-02-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="图片解码"><a href="#图片解码" class="headerlink" title="图片解码"></a>图片解码</h2><p>通过 imageNamed 创建 UIImage ，并没有进行解码。直到第一次显示到屏幕上时，才进行图片解码。解码结果会保存在全局缓存中。<br>通过 imageWithData 创建 UIImage ，也一样没进行解码，直到第一次绘制才会解码。不同的是，如果此时图片释放掉，则解码数据也会释放掉。</p>
<p>图片解码会造成很大CPU占用，可以通过提前解码或者异步解码来优化。 </p>
<h2 id="通过-CGDataProviderCopyData-解码"><a href="#通过-CGDataProviderCopyData-解码" class="headerlink" title="通过 CGDataProviderCopyData 解码"></a>通过 CGDataProviderCopyData 解码</h2><p>Image解码发生在 CGDataProviderCopyData 函数内部，因此可通过该函数进行解码。</p>
<pre><code>CGImageRef imageRef

// 获取图片属性
size_t width = CGImageGetWidth(imageRef);
size_t height = CGImageGetHeight(imageRef);
CGColorSpaceRef space = CGImageGetColorSpace(imageRef);
size_t bitsPerComponent = CGImageGetBitsPerComponent(imageRef);
size_t bitsPerPixel = CGImageGetBitsPerPixel(imageRef);
size_t bytesPerRow = CGImageGetBytesPerRow(imageRef);
CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(imageRef);

// 生成解码后CGDataProviderRef
CGDataProviderRef dataProvider = CGImageGetDataProvider(imageRef);
CFDataRef data = CGDataProviderCopyData(dataProvider);     // 解码
CGDataProviderRef newProvider = CGDataProviderCreateWithCFData(data);

// 生成解码后CGImageRef
CGImageRef newImage = CGImageCreate(width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, space, bitmapInfo, newProvider, NULL, false, kCGRenderingIntentDefault);

CFRelease(data);
CFRelease(newProvider);
</code></pre><h2 id="画布重绘解码"><a href="#画布重绘解码" class="headerlink" title="画布重绘解码"></a>画布重绘解码</h2><p>把图片用 CGContextDrawImage() 绘制到画布上，然后把画布的数据取出来当作图片。</p>
<pre><code>CGImageRef imageRef

size_t width = CGImageGetWidth(imageRef);
size_t height = CGImageGetHeight(imageRef);
CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;
bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;
CGColorSpaceRef space ;
dispatch_once(&amp;onceToken, ^{
   space = CGColorSpaceCreateDeviceRGB();
});

// same as UIGraphicsBeginImageContext() and -[UIView drawRect:]
CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, space, bitmapInfo);     // 创建上下文
CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);     // 绘制解码
CGImageRef newImage = CGBitmapContextCreateImage(context);     // 生成解码后图片

CFRelease(context);
</code></pre><h2 id="图片渐进显示"><a href="#图片渐进显示" class="headerlink" title="图片渐进显示"></a>图片渐进显示</h2><p>使用一下方式图片能有很好的渐进显示效果：</p>
<p>首先用 CGImageSourceCreateIncremental(NULL) 创建一个空的图片源<br>随后在获得新数据时调用CGImageSourceUpdateData(data, false) 来更新图片源<br>最后在用 CGImageSourceCreateImageAtIndex() 创建图片来显示</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/05/iOS绘制性能/" itemprop="url">
                  QuartzCore 和 CoreGraphics
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2017-02-05T11:24:05+08:00" content="2017-02-05">
              2017-02-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>使用CoreGraphics绘图效率较低，并且会消耗较多内存。一般在CALayer的-drawLayer:inContext:方法或者UIView中的-drawRect:方法中，每次绘制图层都会创建一个绘制上下文，上下文所需的内存大小:图层宽 <em> 图层高 </em> 4字节。重绘视图的代价比较昂贵，所以尽量避免重新绘制视图。</p>
<p>如果只是使用CALayer直接赋值给contents属性一张图片，来进行绘制，不会消耗过多的内存，并且同一张图片被多个图层作为contents属性，他们会公用一块内存。</p>
<h2 id="Core-Graphics"><a href="#Core-Graphics" class="headerlink" title="Core Graphics"></a>Core Graphics</h2><p>CoreGraphics绘制层次较多、内容较复杂的情况下使用。</p>
<p>提升CoreGraphics绘制性能，-setNeedsDisplay每次都会对整个区域进行重新绘制，可使用-setNeedsDisplayInRect:，使用该方法标记需要的重绘区域，避免每次重复绘制没有变动的区域。</p>
<h2 id="QuartzCore"><a href="#QuartzCore" class="headerlink" title="QuartzCore"></a>QuartzCore</h2><p>QuartzCore 提供了些不同绘制类型的图层类，并提供了硬件支持。<br>如果想自定义view的图层类型，实现UIView的+(class) layerClass{}函数。</p>
<pre><code>+ (Class)layerClass {
    return [CAShapeLayer class];
}
</code></pre><h3 id="CALayer"><a href="#CALayer" class="headerlink" title="CALayer"></a>CALayer</h3><p>CALayer 绘制图片，可放缩。</p>
<pre><code>CALayer *layer = [CALayer layer];
layer.frame = CGRectMake(50, 50, 100, 100);
layer.contentsRect = CGRectMake(0, 0, 1, 1); //设置放缩区域
layer.contentsGravity = kCAGravityResize;    //设置填充方式
layer.contentsCenter = CGRectMake(0.5, 0.5, 0.0, 0.0); //设置拉伸区域
layer.contentsScale = [UIScreen mainScreen].scale;
layer.contents = (__bridge id)[UIImage imageNamed:@&quot;Circle.png&quot;].CGImage;
</code></pre><h3 id="CAShapeLayer"><a href="#CAShapeLayer" class="headerlink" title="CAShapeLayer"></a>CAShapeLayer</h3><p>CAShapeLayer 绘制多边形，曲线，可替代圆角。</p>
<pre><code>CAShapeLayer *layer = [CAShapeLayer layer];
layer.frame = CGRectMake(50, 50, 100, 100);
layer.fillColor = [UIColor blueColor].CGColor;
layer.path = [UIBezierPath bezierPathWithRoundedRect:
CGRectMake(0, 0, 100, 100) cornerRadius:20].CGPath;
</code></pre><h3 id="CATextLayer"><a href="#CATextLayer" class="headerlink" title="CATextLayer"></a>CATextLayer</h3><p>CATextLayer 绘制文本。</p>
<pre><code>CATextLayer *lary = [CATextLayer layer];
lary.string = @&quot;dasfasa&quot;;
lary.bounds = CGRectMake(0, 0, 320, 20);
lary.font = @&quot;HiraKakuProN-W3&quot;;
lary.fontSize = 12.f;
lary.alignmentMode = kCAAlignmentCenter;//字体的对齐方式
lary.position = CGPointMake(160, 410);
lary.foregroundColor = [UIColor redColor].CGColor;//字体的颜色
</code></pre><h3 id="CAGradientLayer"><a href="#CAGradientLayer" class="headerlink" title="CAGradientLayer"></a>CAGradientLayer</h3><p>CAGradientLayer 绘制渐变色</p>
<pre><code>CAGradientLayer *gradientLayer = [CAGradientLayer layer];
gradientLayer.frame = self.containerView.bounds;
gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor, (__bridge id) [UIColor yellowColor].CGColor, (__bridge id)[UIColor greenColor].CGColor]; //设置渐变色
gradientLayer.locations = @[@0.0, @0.25, @0.5]; //设置过度点
gradientLayer.startPoint = CGPointMake(0, 0);  //设置起点
gradientLayer.endPoint = CGPointMake(1, 1);  //设置终点
</code></pre><h3 id="CATransform3D、CATransformLayer"><a href="#CATransform3D、CATransformLayer" class="headerlink" title="CATransform3D、CATransformLayer"></a>CATransform3D、CATransformLayer</h3><hr>
<h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><p>CALayer 启用 shouldRasterize 属性会将图层绘制到一个屏幕之外的图像。然后这个图像将会被缓存起来并绘制到实际图层的contents和子图层。如果有很多的子图层或者有复杂的效果，使用shouldRasterize会带来性能提升。但是光栅化原始图像需要时间，而且还会消耗额外的内存。如果图层不断变动，不建议开启该属性。</p>
<h3 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h3><p>当图层未预合成之前，要进行屏幕外渲染。会带来性能上的开销。以下情况会出现离屏渲染：</p>
<ul>
<li>同时使用圆角和maskToBounds</li>
<li>阴影</li>
<li>遮盖(mask属性)</li>
</ul>
<h3 id="异步绘制"><a href="#异步绘制" class="headerlink" title="异步绘制"></a>异步绘制</h3><p>异步绘制方法：</p>
<ul>
<li>另外一个线程上绘制内容，然后将由此绘出的图片直接设置为图层的内容。</li>
<li>使用 CALayer 的 drawsAsynchronously 属性，drawsAsynchronously属性对传入 -drawLayer:inContext: 的CGContext进行改动，允许CGContext延缓绘制命令的执行以至于不阻塞用户交互。</li>
<li>使用 CATiledLayer ，它的 -drawLayer:inContext: 方法只会在主线程调用，但是CGContext并不等待每个绘制命令的结束。它会将命令加入队列，在后台线程逐个执行绘制。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/06/iOS https CA证书的验证/" itemprop="url">
                  iOS https CA证书的验证
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2017-01-06T10:28:38+08:00" content="2017-01-06">
              2017-01-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="App-Transport-Security"><a href="#App-Transport-Security" class="headerlink" title="App Transport Security"></a>App Transport Security</h2><p>iOS9新特性ATS，原HTTP请求会转向TLS1.2协议进行传输，意味着强制使用了HTTPS协议进行传输。</p>
<h2 id="CA证书环境搭建"><a href="#CA证书环境搭建" class="headerlink" title="CA证书环境搭建"></a>CA证书环境搭建</h2><p>1.创建根证书私钥：openssl genrsa -des3 -out root.key<br>2.创建根证书申请文件：openssl req -new -key root.key -out root.csr<br>3.创建根证书：openssl x509 -req -days 3650 -sha1 -extensions v3_ca -signkey root.key -in root.csr -out root.crt<br>4.创建服务器证书私钥：openssl genrsa –des3 -out server.key 2048<br>5.创建服务器证书申请文件：openssl req -new -key server.key -out server.csr<br>6.创建服务器证书：openssl x509 -req -days 730 -sha1 -extensions v3_req -CA root.crt -CAkey root.key -CAcreateserial -in server.csr -out server.crt</p>
<h2 id="证书的验证"><a href="#证书的验证" class="headerlink" title="证书的验证"></a>证书的验证</h2><p>在使用NSURLSession时，通过一下代理方法来进行证书的验证：</p>
<pre><code>- (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler {

    NSURLCredential *cre = nil;
    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;
    SecTrustRef trust = challenge.protectionSpace.serverTrust;

    // 1.判断是服务器认证
    if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) {

        // 2.设置校验策略
        NSMutableArray *policies = [NSMutableArray array];
        NSString *domain = nil; // 域名
        if (domain) {
            // 域名校验
            [policies addObject:(__bridge id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)];
        } else {
            [policies addObject:(__bridge id)SecPolicyCreateBasicX509()];
        }
        SecTrustSetPolicies(trust, (__bridge CFArrayRef)policies);

        // 3.获取本地证书 （工程里添加签发证书）
        NSArray *paths = [[NSBundle mainBundle] pathsForResourcesOfType:@&quot;cer&quot; inDirectory:@&quot;.&quot;];
        NSMutableArray *certificates = [NSMutableArray array];
        NSMutableArray *certificatesData = [NSMutableArray array];
        for (NSString *path in paths) {
            NSData *certificateData = [NSData dataWithContentsOfFile:path];
            [certificates addObject:(__bridge id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)];
            [certificatesData addObject:certificateData];
        }

        // 4.配置本地证书来验证服务器返回证书
        SecTrustSetAnchorCertificates(trust, (__bridge CFArrayRef)certificates);

        // 5.默认为YES,不会再使用系统内置根证书验证。设置NO，会使用系统内置证书验证。(该方法的设置放在，上面设置本地证书之后。)
        SecTrustSetAnchorCertificatesOnly(trust,NO);

        // 6.进行证书评估
        SecTrustResultType result;
        SecTrustEvaluate(trust, &amp;result);
        bool isValid = (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);

        cre = [NSURLCredential credentialForTrust:trust];

        // NSURLSessionAuthChallengeUseCredential 使用证书
        // NSURLSessionAuthChallengeCancelAuthenticationChallenge 取消请求
        disposition = isValid ? NSURLSessionAuthChallengeUseCredential : NSURLSessionAuthChallengeCancelAuthenticationChallenge;

    }

    completionHandler(disposition,cre);
}
</code></pre><h2 id="AFNetworking-验证方式"><a href="#AFNetworking-验证方式" class="headerlink" title="AFNetworking 验证方式"></a>AFNetworking 验证方式</h2><h3 id="校验证书内容"><a href="#校验证书内容" class="headerlink" title="校验证书内容"></a>校验证书内容</h3><pre><code>case AFSSLPinningModeCertificate: {
    NSMutableArray *pinnedCertificates = [NSMutableArray array];
    for (NSData *certificateData in self.pinnedCertificates) {
        [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)];
    }
    SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);

    if (!AFServerTrustIsValid(serverTrust)) {
        return NO;
    }

    // obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it&apos;s the Root CA)
    NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);

    // 遍历证书链，对比证书内容
    for (NSData *trustChainCertificate in [serverCertificates reverseObjectEnumerator]) {
        if ([self.pinnedCertificates containsObject:trustChainCertificate]) {
            return YES;
        }
    }

    return NO;
}
</code></pre><h3 id="校验证书公钥"><a href="#校验证书公钥" class="headerlink" title="校验证书公钥"></a>校验证书公钥</h3><pre><code>case AFSSLPinningModePublicKey: {
    NSUInteger trustedPublicKeyCount = 0;
    NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);

    // 遍历证书链，对比公钥
    for (id trustChainPublicKey in publicKeys) {
        for (id pinnedPublicKey in self.pinnedPublicKeys) {
            if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) {
                trustedPublicKeyCount += 1;
            }
        }
    }
    return trustedPublicKeyCount &gt; 0;
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/23/KVO:KVC/" itemprop="url">
                  KVO KVC 实现过程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-12-23T11:53:57+08:00" content="2016-12-23">
              2016-12-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h2><p>KVC(键值编码),提供了一种使用字符串而不是访问器方法去访问对象实例变量的机制。</p>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p> [object setValue: forKey:<key>]</key></p>
<p> [object valueForKey:<key>]</key></p>
<p> 通过runtime的动态能力，实现以下过程：</p>
<p> 1.按顺序检测-get\<key>、-\<key>、-is\<key>、-_get\<key>、-_\<key>访问器方法，如果存在，使用访问器返回值。</key></key></key></key></key></p>
<p> 2.按顺序检测-set\<key>、-_set\<key>、-setIs\<key>访问器方法，如果存在，使用访问器赋值。</key></key></key></p>
<p> 3.如果未实现访问器方法，直接查找实例变量列表，按顺序检测变量名： _\<key>、\<key> 、_is\<key>、is\<key> 如果存在变量，直接进行访问。</key></key></key></key></p>
<p> 4.如果仍未找到变量，调用valueForUndefinedKey:和setValue:forUndefinedKey:方法，默认实现会抛出异常。</p>
<h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><p>  NSNumber *sum = [array valueForKeyPath:@”@sum.key”]; //求和</p>
<p>  NSNumber *avg = [array valueForKeyPath:@”@avg.key”]; //平均值</p>
<p>  NSNumber *max = [array valueForKeyPath:@”@max.key”]; //最大值</p>
<p>  NSNumber *min = [array valueForKeyPath:@”@min.key”]; //最小值</p>
<p>  NSArray *arr = [array valueForKeyPath:@”@unionOfObjects.name”]; //返回key path所指的对象集合</p>
<p>  NSArray *arr = [array valueForKeyPath:@”@distinctUnionOfObjects.name”]; //返回去重后，key path所指的对象集合</p>
<p>  NSArray *arr = [arrays valueForKeyPath:@”@distinctUnionOfArrays.name”]; //返回嵌套数组中key path所指的对象集合</p>
<p>  NSArray *arr = [arrays valueForKeyPath:@”@unionOfArrays.name”]; //返回嵌套数组中去重后，key path所指的对象集合</p>
<h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>KVO(键值观察),提供了一种在修改对象属性时可以通知目标对象的机制。</p>
<h3 id="实现过程-1"><a href="#实现过程-1" class="headerlink" title="实现过程"></a>实现过程</h3><p>[objct addObserver: forKeyPath: options: context:]</p>
<p>[objct setValue: forKey:]</p>
<p>当对象被观察，运行时系统会创建一个派生类：</p>
<p>  1.重写class方法，返回继承类的class。</p>
<p>  2.重写set方法，增加两个方法调用：</p>
<pre><code>- (void)willChangeValueForKey:(NSString *)key
- (void)didChangeValueForKey:(NSString *)key
</code></pre><p>当对象属性被修改时：</p>
<p>  1.若有实现set方法，则在派生类重写的set方法中调用</p>
<pre><code>- (void)willChangeValueForKey:(NSString *)key
- (void)didChangeValueForKey:(NSString *)key
</code></pre><p>  2.若没有实现set方法，则直接在[objct setValue: forKey:]中调用</p>
<pre><code>- (void)willChangeValueForKey:(NSString *)key
- (void)didChangeValueForKey:(NSString *)key
</code></pre><p>KVO被触发的时机：</p>
<p>  1.调用[objct setValue: forKey:]</p>
<p>  2.调用set方法</p>
<p>  3.调用-willChangeValueForKey: 和 -didChangeValueForKey:</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/10/iOS消息机制/" itemprop="url">
                  iOS 消息机制和转发过程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-08-10T14:16:16+08:00" content="2016-08-10">
              2016-08-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对iOS消息机制和转发过程的知识进行梳理和总结。希望能帮助有需要的朋友重新学习一下这方面的知识。</p>
<h2 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>消息机制是在RunTime中很重要的一部分，是系统运行时的重要机制。</p>
<p>OC的函数调用抽象为消息发送的形式，由于是在运行时发生的所以这个过程是动态调用。这点和C语言不同，C的函数调用以及顺序都是在编译时完成。而OC在编译阶段只是通过方法选择器selector（SEL）进行检测，只要有申明该方法就会编译通过。但OC函数的构成出了SEL，还由一个implement (IML) 组成，IML才是真正的函数实现。所以真正的函数调用，是在运行时根据SEL找到IML进行调用。</p>
<h3 id="消息发送过程："><a href="#消息发送过程：" class="headerlink" title="消息发送过程："></a>消息发送过程：</h3><ol>
<li>[obj method] 转化为 objc_megSend(obj,@selector(method)) </li>
<li>通过obj的isa指针找到对应的class。然后先去class的cashe中，通过SEL查找对应的函数method。若cache中未找到，再去方法列表methodlist中查找。若也没找到，再去superClass中以同样的顺序查找。</li>
<li>直到找到，并将method放入到cache中，最终通过method中的函数指针进行函数调用。</li>
</ol>
<h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><h3 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h3><p>在以上对消息机制中描述中存在一种存在一种可能，就是在当前类和父类中都没找到对应方法的实现，这时在运行时机制中不会立即报错，而是进行消息转发。</p>
<h3 id="消息转发的过程："><a href="#消息转发的过程：" class="headerlink" title="消息转发的过程："></a>消息转发的过程：</h3><ol>
<li><p>动态方法解析：向当前类发送resolveInstanceMethod：消息，检测是否动态向该类添加了方法。添加了则返回YES，否则返回NO进行下面的转发过程。</p>
<pre><code>void resolveMethodIMP(id self, SEL sel)
{
    // implementation
}

+ (BOOL)resolveInstanceMethod:(SEL)sel
{
    if (sel == @selector(resolveMethod))
     {
        class_addMethod([self class], sel, (IMP)resolveMethodIMP, &quot;v@:&quot;);
         return YES;
      }
        return [super resolveInstanceMethod:sel];
} 
// &quot;v@:&quot; 组合字符表示函数类型 v-&gt;void @-&gt;参数id :-&gt;参数SEL
</code></pre></li>
<li><p>快速消息转发：检查该类是否实现了forwardingTargetForSelector方法，如实现了再调用该方法。若该方法返回值对象不为空并且不是self，则消息转发给返回的新对象。否则继续下面的转发流程。</p>
<pre><code>- (id)forwardingTargetForSelector:(SEL)aSelector
{
    Target *target = [Target new];
    if ([target respondsToSelector:aSelector])
    {
        return target;
    }
    return [super forwardingTargetForSelector:aSelector];
}
</code></pre></li>
<li><p>标准消息转发：最后一步检测发送methodSignatureForSelector：消息获取selector对应的签名。获取到签名则通过forwardInvocation：转发消息，否则报错抛出异常。</p>
<pre><code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
{
    if (aSelector == @selector(method))
     {
        //为method注册一个无参无返的方法签名
        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];
   }else{
         //抛出异常
        return nil;
     }
}

- (void)forwardInvocation:(NSInvocation *)anInvocation
{
       //进行你想要的操作，或者转发给其它对象
    Target *target = [Target new];
    if ([target respondsToSelector:anInvocation.selector]) {
        [anInvocation setTarget:target];
        [anInvocation invoke];
    }
}
</code></pre></li>
</ol>
<p><strong>PS:以上则是个人对消息发送机制的理解和总结。</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/10/iOS/" itemprop="url">
                  FF
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-08-10T13:16:57+08:00" content="2016-08-10">
              2016-08-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/1m0i371U1A1D0T0J1u04/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-10%20%E4%B8%8B%E5%8D%881.00.56.png" alt="image"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="FF" />
          <p class="site-author-name" itemprop="name">FF</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">Artikel</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">Kategorien</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">Tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FF</span>
</div>

<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
